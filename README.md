Installation & Run

1. Clone the repository

git clone https://github.com/r1nozaki/leasing-cars.git cd leasing-cars

2. Install dependencies

npm install

3. Setup environment variables

Create a .env file in the root of the project:
DATABASE_URL="postgresql://USER:PASSWORD@localhost:5432/DATABASE_NAME"

4. Push Prisma schema to database

npx prisma db push

5. Seed the database

npx prisma db seed

6. Run the development server

npm run dev

Self-review

Основні труднощі

1. Робота з Prisma та взаємодія з базою даних

Найбільшим викликом на початку була робота з Prisma, оскільки раніше я не мав
досвіду з ORM та серверною частиною. Це вже більше бекенд-напрямок, а мій
основний фокус — фронтенд.

Спочатку було складно зрозуміти:

як працює схема Prisma,

як відбувається синхронізація з базою (db push),

як правильно формувати запити з умовною фільтрацією.

Я вирішив цю проблему через:

детальне вивчення офіційної документації Prisma,

перегляд кількох технічних відео,

експерименти з тестовими запитами.

У результаті я краще зрозумів принципи роботи ORM та взаємодію серверної логіки
з клієнтською частиною. Це був цікавий досвід і хороший крок у розширенні
технічного стеку.

2. Синхронізація стану "Обраного"

Викликом була реалізація системи лайків, яка б працювала миттєво для
користувача, але при цьому залишалася надійною на стороні сервера.

Миттєвий відгук: У сторі Zustand я реалізував логіку, яка спочатку оновлює
локальний масив ids (додає або видаляє авто), що дає користувачу миттєву
візуальну зміну стану кнопки (червоне серце).

Асинхронна мутація: Паралельно з оновленням стору викликається серверний екшен
toggleFavoriteAction, який записує зміни в базу даних через Prisma.

Обробка помилок (Rollback): Якщо серверний запит зазнає невдачі (наприклад,
проблеми зі зв'язком), стор автоматично відкочує зміни до попереднього стану
(saved currentIds), повертаючи UI у відповідний стан.

Валідація через Middleware: Щоб Server Action знав, чий саме це лайк (без
авторизації), я інтегрував deviceId через Cookies, який перевіряється в
Middleware перед кожним запитом.

3. Досвід роботи з Zod

У цьому проєкті я обрав Zod для валідації схем пошуку та фільтрації. Оскільки
раніше я мав значний досвід роботи з Yup, перехід на Zod виявився дуже легким та
інтуїтивно зрозумілим.

Чому Zod став кращим вибором:

Інтеграція з TypeScript: На відміну від Yup, де іноді доводиться дублювати типи,
Zod дозволяє витягувати типи безпосередньо зі схеми за допомогою z.infer. Це
забезпечило 100% типізацію фільтрів без зайвого коду.

Функція .transform(): Це стало вирішальним фактором. Можливість "на льоту"
перетворювати рядок з URL у число (coerce.number()) або приводити поодинокі
значення до масиву для Prisma зробила обробку searchParams набагато чистішою.

Синтаксична схожість: Логіка побудови об'єктів та методів .optional() чи
.string() дуже схожа на Yup, що дозволило мені почати писати складні схеми вже з
перших хвилин роботи з бібліотекою.
